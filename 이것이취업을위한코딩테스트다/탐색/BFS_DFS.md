# BFS, DFS를 이용한 탐색

### 탐색 keyword: `그래프`, `2차원 배열`, `최단 길이`

> 탐색(search)은 많은 양의 데이터 중 원하는 데이터를 찾는 유형의 문제.
> 탐색 문제는 주로 그래프, 트리 등의 자료구조 안에서 출제되며, 대표적인 탐색 알고리즘인 DFS/BFS를 통해 풀이해야 함.

### 스택 vs 큐

|           | 스택                    | 큐                                                       |
| --------- | ----------------------- | -------------------------------------------------------- |
| 구조      | LIFO                    | FIFO                                                     |
| 생성 방법 | 파이썬 리스트 사용 \[ ] | collections.deque() 사용(필요 시 list()로 감싸 리스트화) |
| 주사용처  | DFS(깊이 우선 탐색)     | BFS(너비 우선 탐색)                                      |
| 삽입/삭제 | append(), pop()         | append(), popleft()                                      |

## DFS vs BFS

### 그래프

> 그래프(Graph) = 노드(Node = Vertex) + 간선(Edge)

- 간선으로 연결된 노드는 서로 adjacent(인접)하다고 표현.
- 그래프 저장하는 자료 구조:

1. 인접 행렬(adjacent matrix) : 2차원 배열에 각 노드가 연결된 형태를 저장.
   - 즉, 자기 자신이면 0, 인접하면 간선의 값, 인접하지 않으면 INF(2e9)를 저장.
2. 인접 리스트(adjacent list): 2차원 리스트 즉, 연결 리스트 형태로 인접한 노드 정보만을 저장. - 노드 i에 연결된 노드의 정보를 \[(노드, 간선 값), (노드, 간선 값), ...] 형태로 저장 - 인접 리스트로 저장할 때 인덱스 0을 \[]로 추가하여 예외처리 해주는 편이 좋음.
   | | 인접 행렬 | 인접 리스트 |
   | ------ | ------------------------------------------ | --------------------------------------- |
   | 메모리 | 모든 노드 정보 저장하므로 메모리 낭비 심함 | 인접한 노드 정보만 저장해 메모리 효율적 |
   | 인접 확인 시간 | i, j 인접 확인 위해 matrix\[i]\[j] 만 확인 O(1) | i, j 확인 위해 i번째 리스트 최악의 경우 전체 순회 O(k) |

### DFS(깊이 우선 탐색): 스택(리스트) + 재귀함수를 통해 구현, 스택 비면 종료. O(N)

- DFS(Depth-First Search): 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘 - 즉, 가장 먼 노드를 우선으로 탐색.
- **DFS 알고리즘은 스택 자료구조 + 재귀함수를 이용해 구현함.**
  > 1. 탐색 시작 노드를 스택에 삽입하고 방문 처리함.
  >    - 즉, 사전에 visited_li = \[False] \* (길이) 로 초기화 필요.
  > 2. 스택의 최상단 노드를 빼고, 해당 노드가 방문하지 않은 인접 노드가 있는지 확인함.
  >    2-1. 방문하지 않은 인접노드가 있다면, 해당 인접 노드를 스택에 삽입하고 방문처리 수행.
  >    - 이 때, 인접 노드 중 방문하지 않은 노드가 여러개라면, 번호가 낮은 순서부터 처리함.
  >      2-2. 방문하지 않은 인접노드가 없다면, 스택에서 다시 최상단 노드를 꺼냄.
  > 3. 2 과정을 더 이상 수행할 수 없을 때까지 수행함.
  >
  > - 즉, 스택이 비면 종료됨

```python
# 굳이 스택을 사용하지 않고, 재귀함수로 구현 가능(왜냐하면 재귀함수는 내부적으로 스택 기반 동작)
def dfs(graph_li, v, visited_li):
	visited_li[v] = True
	print(v, end=' ') # 방문처리 됨
	for i in graph_li[v]:
		if not visited_li[i]:
			dfs(graph_li, i, visited_li)

graph_li = [
			[],
			[2, 3, 8],
			[1, 7],
			[1, 4, 5],
			[3, 5],
			[3, 4],
			[7],
			[2, 6, 8],
			[1, 7]
]

visited_li = [False] * len(graph_li)

dfs(graph_li, 1, visited_li)
```

### BFS(너비 우선 탐색): 큐(deque) 통해 구현. 큐 비면 종료. O(N)

BFS(Breadth-First Search): 그래프에서 가까운 노드부터 탐색하는 알고리즘.

- **BFS 알고리즘은 큐를 이용해 구현함.**
  > 1. 탐색 시작 노드를 큐에 삽입하고 방문 처리함.
  >    - 즉, 사전에 visited_li = \[False] \* (길이) 로 초기화 필요.
  > 2. 큐에서 노드를 꺼내, 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입
  >    - 즉, deq.popleft() 한 노드의 인접 노드를 모두 deq.append((인접노드, 간선값)) 처리
  > 3. 2번 과정을 더 이상 수행할 수 없을 떄까지 반복

```python
from collections import deque

def bfs(graph_li, v, visited_li):
	queue = deque([v])
	visited_li[v] = True
	print(v, end=' ') # 방문처리
	while queue:
		v = queue.popleft()
		for i in graph_li[v]:
			if not visited_li[i]:
				queue.append(i)
				visited_li[i] = True
				print(i, end=' ') # 방문처리
graph_li = [
			[],
			[2, 3, 8],
			[1, 7],
			[1, 4, 5],
			[3, 5],
			[3, 4],
			[7],
			[2, 6, 8],
			[1, 7]
]

visited_li = [False] * len(graph_li)

bfs(graph_li, 1, visited_li)
```
